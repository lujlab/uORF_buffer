# uORF_buffer

This repository stores the scripts used for simulation of the translation process of an mRNA molecule with one upstream ORF (uORF) and one main ORF (mORF/CDS). The model used here is based on Andreev et al.'s ICIER model [(ref)](https://elifesciences.org/articles/32563), which is distributed under GPLv3 licence at the following address: [https://github.com/maximarnold/uORF_TASEP_ICIER](https://github.com/maximarnold/uORF_TASEP_ICIER). The original model is implemented in MATLAB, and we adpated it using python. <br/>
The basic framework of this model is totally asymmetric simple exclusion process (TASEP). Briefly, we silmulate the translation process of an mRNA molecule by a series of discrete actions, like a series of frames in a film. The mRNA molecule is represented by an array (a pyhthon list object filled with integers), and the value of each position represents the occupation status of ribosomes. In each action, certain events may happen with certain probabilities, represented by the changes of the values in the array.

## Usage of the scripts
The core components of the model is integrated into the file [ICIER_extended_v8.py](https://github.com/lujlab/uORF_buffer/blob/main/ICIER_extended_v8.py). In this file, the function `Sim_main(condition_set)` executes a single run of simulation. Based on the previous one, the function `Sim_multi_condition(condition_list, outfile_path)` executes multiple runs of simulation.<br/>
`Sim_main(condition_set)` takes a dictionary as the only input, and the requisite items of the dictionary can be found at the begining of [ICIER_extended_v8.py](https://github.com/lujlab/uORF_buffer/blob/main/ICIER_extended_v8.py), in the `default_condition_set`. Such a dictionary specifies all parameters necessary for a single run of simulation.<br/>
`Sim_multi_condition(condition_list, outfile_path)` takes two input objects, where `condition_list` is a list of dictionaries that fit `Sim_main()`, and `outfile_path` is a string specifying the path of a text file where you would like to save the results.<br/>
For a batch of simulation, you need to first creat a list of dictionaries, then utilize `Sim_multi_condition(condition_list, outfile_path)`. This can be done with a separate script, let's take [1000Lambda_runif__11P_s2p_u__11P_s2p_m__v8_downstream_dissociation.py](https://github.com/lujlab/uORF_buffer/blob/main/1000Lambda_runif__11P_s2p_u__11P_s2p_m__v8_downstream_dissociation.py) as an example. In this script, we aim to simulate translation processes under 1000 values of Lambda (i.e., *R<sub>in</sub>*)(Generated by a random generator of uniform distribution, stored in the file [Lambda_input/num_runif.txt](https://github.com/lujlab/uORF_buffer/blob/main/Lambda_input/num_runif.txt)), 11 values of P_s2p_u (i.e., *I<sub>uORF</sub>*)(0, 0.1, 0.2,..., 1) and 11 values of P_s2p_m (i.e., *I<sub>CDS</sub>*)(0, 0.1, 0.2, ..., 1), thus there will be a total of 1000\*11\*11 = 121000 runs.<br/>
We first create a list containing 121000 dictionaries corresponding to the 121000 kinds of conditions we want to simulate, like this:
```python
from ICIER_extended_v8 import *

condition_list = []

with open('Lambda_input/num_runif.txt', 'r') as r_in_file:
    r_in_lines = r_in_file.readlines()  # read the 1000 R_in values.

for i in [k / 10 for k in range(0, 11)]:
    for j in [k / 10 for k in range(0, 11)]:
        for k in r_in_lines:
            tmp = default_condition_set.copy()  # default_condition_set has been imported from ICIER_extended_v8.py
            tmp['Lambda'] = float(k.split('\t')[1])
            tmp['P_s2p_u'] = i
            tmp['P_s2p_m'] = j
            condition_list.append(tmp)
```
Then we use the `Sim_multi_condition(condition_list, outfile_path)` function and specify the output file path here:
```python
Sim_multi_condition(condition_list, 'sim_result/1000Lambda_runif__11P_s2p_u__11P_s2p_m__v8_downstream_dissociation.txt')
```
Run this script, and we will get the result file at sim_result/1000Lambda_runif__11P_s2p_u__11P_s2p_m__v8_downstream_dissociation.txt, which contains a header line and then 121000 lines of results. You can see the example output file at [sim_result/1000Lambda_runif__11P_s2p_u__11P_s2p_m__v8_downstream_dissociation.txt.gz](https://github.com/lujlab/uORF_buffer/blob/main/sim_result/1000Lambda_runif__11P_s2p_u__11P_s2p_m__v8_downstream_dissociation.txt.gz). Note that the output will also be printed to standard output in real time, and you can either discard it or use it to monitor the progress, etc.

## Columns in the result file
The result file is a tab-delimited text file with 40 columns, the first column is the ID of each run, the 2nd to 25th lines (Ls to TTime) are the parameters of condition that are set in the input dictionary, and the 26th to 40th lines (SRNA_started to SRNA_kicked_downstream_m) are the actual output values. Here the description of all the columns are listed. **Note that some parameters and values have different symbols in scripts and in the article, while they are actually the same variable.**
|Column name (symbol in scipts)| Symbol in article|Description|
|---|---|---|
|sim_ID||The id of each run. Generated according to system time.|
|Ls||Length of a 40S ribosome. \[Default: 10\]|
|Le||Length of an 80S ribosome. \[Default: 10\]|
|Len_a|*Len_a*|Length before uATG. \[Default: 50\]|
|Len_u|*Len_u*|Length between uATG and uSTOP, both ends included. (i.e., length of uORF) \[Default: 30\]|
|Len_b|*Len_b*|Length between uSTOP and mATG, both ends not included. \[Default: 50\]|
|Len_m|*Len_m*|Length between mATG and mSTOP, both ends included. (i.e., length of mORF/CDS) \[Default: 500\]|
|Len_c|*Len_c*|Length after mSTOP. \[Default: 50\]|
|Lambda|*R<sub>in</sub>*|Probability of 40S loading in a single action. \[Default: 0.1\]|
|P_delay_au||Probability NOT to delay at au boundary in a single action, 1 means no delay. \[Default: 1\]|
|P_delay_ub||Probability NOT to delay at ub boundary in a single action, 1 means no delay. \[Default: 1\]|
|P_delay_bm||Probability NOT to delay at bm boundary in a single action, 1 means no delay. \[Default: 1\]|
|P_delay_mc||Probability NOT to delay at mc boundary in a single action, 1 means no delay. \[Default: 1\]|
|P_s2p_u|*I<sub>uORF</sub>*|Probability of transformation from 40S to 80S at uATG in a single action. \[Default: 0.1\]|
|P_p2s_u||Probability of transformation from 80S to 40S at uSTOP in a single action (i.e., reinitiation). \[Default: 0\]|
|P_s2p_m|*I<sub>CDS</sub>*|Probability of transformation from 40S to 80S at mATG in a single action. \[Default: 0.9\]|
|P_p2s_m||Probability of transformation from 80S to 40S at mSTOP in a single action (i.e., reinitiation). \[Default: 0\]|
|P_smove|*v<sub>s</sub>*|Probability that a 40S moves to the next position in a single action. \[Default: 0.3\]|
|P_pmove_u|*v<sub>Eu</sub>*|Probability that a 80S located in uORF moves to the next position in a single action. \[Default: 0.3\]|
|P_pmove_m|*v<sub>EC</sub>*|Probability that a 80S loacted in mORF moves to the next position in a single action. \[Default: 0.5\]|
|P_sdeath||Probability of spontaneous 40S dissociation in a single action.  \[Default: 0\]|
|P_edeath||Probability of spontaneous 80S dissociation in a single action.  \[Default: 0\]|
|P_clear_up|*K<sub>up</sub>*|Capacity of the 80S to remove the 40S in a 40S->80S collision, 0 means unable and 1 means able. \[Default: 0\]|
|P_clear_down|*K<sub>down</sub>*|Capacity of the 80S to remove the 40S in a 80S->40S collision, 0 means unable and 1 means able. \[Default: 1\]|
|TTime||Total number of actions in a single run of simulation. \[Default: 1000000\]|
|SRNA_started||Total number of 40S ribosomes that have been loaded to the 5' terminus of the mRNA molecule during the given time (TTime).| 
|SRNA_passed_au||Total number of 40S ribosomes that have reached uATG during the given time (TTime).|
|PRNA_started_u||Total number of ribosomes that have started translation at uATG during the given time (TTime).|
|PRNA_dropped_u||Total number of 80S ribosomes that have spontaneously dropped off in the uORF during the given time (TTime).|
|PRNA_finished_u|*N<sub>Eu</sub>*|Total number of 80S ribosomes that have reached uSTOP and completed uORF translation during the given time (TTime).|
|SRNA_passed_bm||Total number of 40S ribosomes that have reached mATG during the given time (TTime).|
|PRNA_started_m||Total number of ribosomes that have started translation at mATG during the given time (TTime).|
|PRNA_dropped_m||Total number of 80S ribosomes that have spontaneously dropped off in the mORF during the given time (TTime).|
|PRNA_finished_m|*N<sub>EC</sub>*|Total number of 80S ribosomes that have reached mSTOP and completed mORF(i.e., CDS) translation during the given time (TTime).|
|SRNA_dropped||Total number of 40S ribosomes that have spontaneously dropped off during the given time (TTime).|
|SRNA_end||Total number of 40S ribosomes that have reached 3' terminus of the mRNA molecule during the given time (TTime).|
|SRNA_kicked_upstream_u||Total number of 40S ribosomes that have been removed due to a 40S->80S collision in uORF during the given time (TTime).|
|SRNA_kicked_downstream_u||Total number of 40S ribosomes that have been removed due to a 80S->40S collision in uORF during the given time (TTime).|
|SRNA_kicked_upstream_m||Total number of 40S ribosomes that have been removed due to a 40S->80S collision in mORF during the given time (TTime).|
|SRNA_kicked_downstream_m||Total number of 40S ribosomes that have been removed due to a 80S->40S collision in mORF during the given time (TTime).|
